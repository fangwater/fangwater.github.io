<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++内存分配-unqiue_ptr</title>
    <url>/2022/12/22/221222-1/</url>
    <content><![CDATA[<p>本文主要讨论内存角度对<code>C++</code>智能指针<code>unique_ptr</code>的观察</p>
<h2 id="Memory-usage-of-unique-ptr"><a href="#Memory-usage-of-unique-ptr" class="headerlink" title="Memory usage of unique_ptr"></a>Memory usage of unique_ptr</h2><p><code>unique_ptr</code>的内存模型如下<br><img src="/../imgs/22-12-24-0.png" alt="avatar"></p>
<p>由此不难理解,一般的<code>unique_ptr</code>和正常指针的空间占用相同,而当<code>unique_ptr</code>包含自己的<code>delete</code>,其需要在堆上开辟自己的内存空间</p>
<p>一个简单的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    <span class="type">int</span> m_x;</span><br><span class="line">    <span class="type">int</span> m_y;</span><br><span class="line">    <span class="type">int</span> m_z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z):</span><br><span class="line">    <span class="built_in">m_x</span>(x),<span class="built_in">m_y</span>(y),<span class="built_in">m_z</span>(z)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*code here*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在x64下,显然不包含<code>delete</code>的<code>unique_ptr</code>大小是一个普通指针的大小,并没有额外的实现,这和其构造器的实现有关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Widget* pw = <span class="keyword">new</span> <span class="built_in">Widget</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">w1</span><span class="params">(<span class="keyword">new</span> Widget(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> pw;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(w1) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>delete</code>是一个函数对象,则去居于函数对象额外数据大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DeleteObject</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Widget* w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> w;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using DeleteObject&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int64_t</span> padding_size1;</span><br><span class="line">    <span class="type">int64_t</span> padding_size2;</span><br><span class="line">&#125;;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Widget,DeleteObject&gt; <span class="title">w2</span><span class="params">(<span class="keyword">new</span> Widget(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(w2) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//24,8 for ptr and 8+8 for padding</span></span><br></pre></td></tr></table></figure>
<p>使用lldb调试,打印w2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(lldb) <span class="function">p <span class="title">w2</span></span></span><br><span class="line"><span class="function"><span class="params">(std::unique_ptr&lt;Widget, DeleteObject&gt;)</span> $0 </span>= <span class="number">0x55555556d2e0</span> &#123;</span><br><span class="line">  pointer = <span class="number">0x000055555556d2e0</span></span><br><span class="line">  deleter = (padding_size = <span class="number">0</span>, padding_size2 = <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针地址和是数据地址是连续的,函数在别的位置</p>
<p>当<code>delete</code>是一个函数指针,去取决于编译器实现,一般的会增大一个指针的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteFunction</span><span class="params">(Widget* w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> w;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using DeleteFunction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//function delete</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;Widget,<span class="title">void</span><span class="params">(*)</span><span class="params">(Widget*)</span>&gt; <span class="title">w3</span><span class="params">(<span class="keyword">new</span> Widget(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),DeleteFunction)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">sizeof</span>(w3) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//16 function_ptr + unique_ptr</span></span><br></pre></td></tr></table></figure>
<p>此时函数指针的位置被设置在<code>deleter</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(lldb) <span class="function">p <span class="title">w3</span></span></span><br><span class="line"><span class="function"><span class="params">(std::unique_ptr&lt;Widget, <span class="type">void</span> (*)(Widget *)&gt;)</span> $1 </span>= <span class="number">0x55555556d2e0</span> &#123;</span><br><span class="line">  pointer = <span class="number">0x000055555556d2e0</span></span><br><span class="line">  deleter = <span class="number">0x0000555555555220</span> (a.out`<span class="built_in">DeleteFunction</span>(Widget*) at unqiue_test.cpp:<span class="number">23</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>deleter</code>是一个无状态函数,lamda表达式且不带捕获,则不会占用任何内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lambda delete</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">auto</span> lam= [](Widget* w) &#123;</span><br><span class="line">        <span class="keyword">delete</span> w;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;lam delete w&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="function">std::unique_ptr&lt;Widget,<span class="title">decltype</span><span class="params">(lam)</span>&gt; <span class="title">w4</span><span class="params">(<span class="keyword">new</span> Widget(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),lam)</span></span>;</span><br><span class="line">     std::cout &lt;&lt; <span class="built_in">sizeof</span>(w4) &lt;&lt; std::endl;</span><br><span class="line">     std::cout &lt;&lt; <span class="built_in">sizeof</span>(lam) &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过lldb观察,确实没有进行额外的储存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(lldb) <span class="function">p <span class="title">w4</span></span></span><br><span class="line"><span class="function"><span class="params">(std::unique_ptr&lt;Widget, deleter_type&gt;)</span> $3 </span>= <span class="number">0x55555556d2e0</span> &#123;</span><br><span class="line">  pointer = <span class="number">0x000055555556d2e0</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="built_in">lam</span></span><br><span class="line">(deleter_type) $<span class="number">4</span> = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用带捕获的<code>(&amp;)</code> lambda函数,则会获得额外的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//lambda delete with &amp;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">auto</span> lam= [&amp;](Widget* w) &#123;</span><br><span class="line">        <span class="keyword">delete</span> w;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;lam delete w&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="function">std::unique_ptr&lt;Widget,<span class="title">decltype</span><span class="params">(lam)</span>&gt; <span class="title">w5</span><span class="params">(<span class="keyword">new</span> Widget(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),lam)</span></span>;</span><br><span class="line">     std::cout &lt;&lt; <span class="built_in">sizeof</span>(w5) &lt;&lt; std::endl;</span><br><span class="line">     std::cout &lt;&lt; <span class="built_in">sizeof</span>(lam) &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体在内存中则是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(lldb) <span class="function">p <span class="title">lam</span></span></span><br><span class="line"><span class="function"><span class="params">((unnamed <span class="keyword">class</span>))</span> $0 </span>= &#123;</span><br><span class="line">  x = <span class="number">0x00007fffffffdafc</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="built_in">w5</span></span><br><span class="line">(std::unique_ptr&lt;Widget, (unnamed <span class="keyword">class</span>)&gt;) $<span class="number">1</span> = <span class="number">0x55555556d2e0</span> &#123;</span><br><span class="line">  pointer = <span class="number">0x000055555556d2e0</span></span><br><span class="line">  deleter = &#123;</span><br><span class="line">    x = <span class="number">0x00007fffffffdafc</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到额外保存了一份状态信息</p>
<p>那么C++是如何保存和unique_ptr匹配的lambda函数,这涉及到<code>EBO</code></p>
<ul>
<li><a href="/2022/12/24/221224-1/" title="C++编译优化-EBO">&#96;C++编译优化-EBO&#96;</a></li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Course_report</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Memory</tag>
        <tag>Smart_pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11新特性解析与应用1</title>
    <url>/2022/12/24/221224-2/</url>
    <content><![CDATA[<p>C++11新特性解析与应用 阅读tips</p>
<h1 id="1-库和语言的实现-1-4-1"><a href="#1-库和语言的实现-1-4-1" class="headerlink" title="1 库和语言的实现(1.4.1)"></a>1 库和语言的实现(1.4.1)</h1><p>C++11中部分内容并未作为语言标准，也就是编译器实现的一部分，而是使用了库来实现，例如<code>std::thread,std::regex</code><br>其目的是因为随着语义越来越复杂，标准库可以控制复杂性的同时，减少核心语言特性</p>
<h1 id="2-func-2-1-2"><a href="#2-func-2-1-2" class="headerlink" title="2 func(2.1.2)"></a>2 <strong>func</strong>(2.1.2)</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __func__;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">hello</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实质上存在一个编译器的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Tech</category>
        <category>Read_report</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编译优化-EBO</title>
    <url>/2022/12/24/221224-1/</url>
    <content><![CDATA[<h1 id="Empty-Base-Class-Optimisation-EBO"><a href="#Empty-Base-Class-Optimisation-EBO" class="headerlink" title="Empty Base Class Optimisation (EBO)"></a>Empty Base Class Optimisation (EBO)</h1><p><code>EBO</code> 的方法是, 通过继承空基类来避免对象大小的增加</p>
<p>在C++中,一个empty object至少也要占一个字节, 但如果这个对象是以基类部分的形式存在,则不会占用额外的空间</p>
<p>具体的,如果<code>class A</code>为空,则 <code>class B : A</code> 不会增加大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> : A1&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> : A2&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(B1) &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(B2) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 4</span></span><br></pre></td></tr></table></figure>

<h1 id="How-unique-ptr-apply-EBO"><a href="#How-unique-ptr-apply-EBO" class="headerlink" title="How unique_ptr apply EBO"></a>How unique_ptr apply EBO</h1><p>一个<code>EBO</code>使用可见于无状态的<code>lambda deleter</code>在<code>unique_ptr</code> 上的应用</p>
<ul>
<li><a href="/2022/12/22/221222-1/" title="C++内存分配-unqiue_ptr">&#96;C++内存分配-unqiue_ptr</a></li>
</ul>
<p>具体的,参考g++ libc++观察对<code>__uniq_ptr_data</code>的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">using</span> deleter_type  = _Dp;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    tuple&lt;pointer, _Dp&gt; _M_t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>_M_t</code>就是存放指针和<code>deleter</code>的位置, 做一个小的尝试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">B1* b_ptr;</span><br><span class="line"><span class="function">std::tuple&lt;<span class="title">decltype</span><span class="params">(b_ptr)</span>,A1&gt; <span class="title">s</span><span class="params">(b_ptr,A1())</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//8, only b_ptr</span></span><br></pre></td></tr></table></figure>
<p>发现在tuple中,如果元素为空类,其大小会被优化, 由此引发两个问题</p>
<ul>
<li>[1]tuple如何确定A1是一个空类</li>
<li>[2]tuple如何存储这个空类</li>
</ul>
<p>可以在tuple的源码中找到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using EBO for elements that are tuples causes ambiguous base errors.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _El0, <span class="keyword">typename</span>... _El&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__is_empty_non_tuple</span>&lt;tuple&lt;_El0, _El...&gt;&gt; : false_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the Empty Base-class Optimization for empty, non-final types.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">using</span> __empty_not_final</span><br><span class="line">  = <span class="keyword">typename</span> conditional&lt;__is_final(_Tp), false_type,</span><br><span class="line">	   __is_empty_non_tuple&lt;_Tp&gt;&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> _Idx, <span class="keyword">typename</span> _Head,</span><br><span class="line">  <span class="type">bool</span> = __empty_not_final&lt;_Head&gt;::value&gt;</span><br><span class="line">  <span class="keyword">struct</span> _Head_base;</span><br></pre></td></tr></table></figure>
<pre><code>std::cout &lt;&lt; std::is_empty_v&lt;decltype(lam1)&gt; &lt;&lt; std::endl;
std::cout &lt;&lt; std::is_empty_v&lt;decltype(lam2)&gt; &lt;&lt; std::endl;
</code></pre>
<p>而其中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// is_empty</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">is_empty</span></span><br><span class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="type">bool</span>, __is_empty(_Tp)&gt;</span><br><span class="line">  &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>根据是否是空类,会用不同的判定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> lam1= [&amp;](<span class="type">int</span> y) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lam with state&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(lam1) &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> lam2 = [](<span class="type">int</span> y) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lam without state&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; std::is_empty_v&lt;<span class="keyword">decltype</span>(lam1)&gt; &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::is_empty_v&lt;<span class="keyword">decltype</span>(lam2)&gt; &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 0 1</span></span><br></pre></td></tr></table></figure>
<p>tuple实现的时候,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> _Idx, <span class="keyword">typename</span> _Head, <span class="keyword">typename</span>... _Tail&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_Tuple_impl</span>&lt;_Idx, _Head, _Tail...&gt;</span><br><span class="line">  : <span class="keyword">public</span> _Tuple_impl&lt;_Idx + <span class="number">1</span>, _Tail...&gt;,</span><br><span class="line">    <span class="keyword">private</span> _Head_base&lt;_Idx, _Head&gt;</span><br></pre></td></tr></table></figure>

<p> <code>public</code> 继承表达的<code>is-a</code>关系，<code>private</code> 继承隐含的意思其实是 <code>is-implemented-in-terms-of</code>，即<code>由…实现出</code><br>这里表示,<code>_Head_base</code>是其中的一部分,我们获得了<code>_Head_base</code>的接口,但这只是一个特化的空类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> _Idx, <span class="keyword">typename</span> _Head, <span class="type">bool</span> = __empty_not_final&lt;_Head&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> _Head_base;</span><br><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> _Idx, <span class="keyword">typename</span> _Head&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Head_base</span>&lt;_Idx, _Head, <span class="literal">true</span>&gt; : <span class="keyword">public</span> _Head</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Memory</tag>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title>新冠感染记录1</title>
    <url>/2022/12/27/221227-1/</url>
    <content><![CDATA[<h1 id="新冠感染记录"><a href="#新冠感染记录" class="headerlink" title="新冠感染记录"></a>新冠感染记录</h1><p>记录上海开放后的感染记录</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>体感症状</th>
<th>抗原</th>
</tr>
</thead>
<tbody><tr>
<td>2022-12-25-9:00</td>
<td>肩背发力不畅,手背,手腕关节偶发酸软</td>
<td>neg</td>
</tr>
<tr>
<td>2022-12-25-18:00</td>
<td>嗓子有轻微干痒,不咳嗽</td>
<td>neg</td>
</tr>
<tr>
<td>2022-12-25-20:00</td>
<td>畏寒,酸软增加腿部(轻微,不持续)</td>
<td>neg</td>
</tr>
<tr>
<td>2022-12-25-22:00</td>
<td>低烧,37-38,长思考断片,疲劳,嗓子不适消失,一般对话聊天逻辑没有问题</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-25-1:28</td>
<td>低烧,最后一次测量37.1</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-26-7:40</td>
<td>退烧,有疲劳感,剧烈动作有眩晕感,嘴唇有一处溃疡</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-26-10:00</td>
<td>咽喉不适明显,已无发烧相关症状,恢复办公</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-26-19:00</td>
<td>咽喉不适明显,咳嗽,有黄痰,怀疑合并感染,服阿莫西林0.5*2g</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-27-4:00</td>
<td>再无黄痰,白痰+流涕,咽喉干痒,偶尔咳嗽</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-27-8:40</td>
<td>喉咙依然不适,症状变化不大,鼻涕增多</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-27-14:25</td>
<td>喉咙依然不适,症状变化不大</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-27-22:00</td>
<td>喉咙依然不适,症状变化不大</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-28-9:30</td>
<td>喉咙不适,刚起来比较干燥</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-28-12:00</td>
<td>喉咙不适,流鼻涕多,鼻塞</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-28-13:39</td>
<td>喉咙依然不适,痒,但吞咽的不适已经消失很多</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-30-09:00</td>
<td>干咳</td>
<td>pos</td>
</tr>
<tr>
<td>2022-12-31-18:00</td>
<td>干咳</td>
<td>弱阳</td>
</tr>
<tr>
<td>2023-01-01-18:00</td>
<td>几乎不阳</td>
<td>弱阳</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Life</category>
        <category>Record</category>
      </categories>
      <tags>
        <tag>COVID_19</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内存分配-shared_ptr和weak_ptr</title>
    <url>/2022/12/28/221228-1/</url>
    <content><![CDATA[<p>本文主要讨论内存角度对<code>C++</code>智能指针<code>shared_ptr和weak_ptr</code>的观察</p>
<p>这一部分的讨论不在于其内存是如何分配和构造,而在于如何恰当的使用</p>
<p><code>shared_ptr和weak_ptr</code>具有如下的数据结构<br><img src="/../imgs/22-12-28-0.png" alt="avatar"></p>
<p>首先,不必过于关注控制块的内存开销,其实质上<code>shared_ptr和weak_ptr</code>一般是多个指针对应一个对象，因此摊销之后成本有限</p>
<h2 id="make-shared的使用"><a href="#make-shared的使用" class="headerlink" title="make_shared的使用"></a>make_shared的使用</h2><p>make_shared理论上是一个更好的选择，因为原生指针对象和控制块一次进行分配，可以增加cache的局部性，更主要是减少一次内存分配的开销</p>
<p>如果只使用shared_ptr，而不用<code>weak_ptr</code>的情况，至少<code>make_shared</code>在大部分时候应该没有问题，但如果同时使用了<code>shared_ptr和weak_ptr</code>, 一种情况是, shared_ptr已经全部释放，相当于引用计数为0，但还有<code>weak_ptr</code>没有离开作用域，导致延迟了内存的释放事件，尤其是在内存紧张的嵌入式环境需要考虑</p>
<h2 id="enable-shared-from-this原理"><a href="#enable-shared-from-this原理" class="headerlink" title="enable_shared_from_this原理"></a>enable_shared_from_this原理</h2><h3 id="何时需要enable-shared-from-this"><a href="#何时需要enable-shared-from-this" class="headerlink" title="何时需要enable_shared_from_this"></a>何时需要<code>enable_shared_from_this</code></h3><p>当需要this指针封装<code>shared_ptr</code>, <code>shared_ptr&lt;T&gt;(this)</code>这种用法是错误的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">shared_ptr&lt;Widget&gt; <span class="title">getWidget</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Widget</span>()&#123; cout &lt;&lt; <span class="string">&quot;~widget &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Widget&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Widget())</span></span>;</span><br><span class="line">    shared_ptr&lt;Widget&gt; sp2 = sp1-&gt;<span class="built_in">getWidget</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sp1和sp2显然指向同一个对象，但是引用计数都是1，对于上述问题，原因在于sp1和sp2对应两个控制块，但只指向了一个对象，属于双重所有权的问题，最后导致了double free</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(lldb) <span class="function">p <span class="title">sp1</span></span></span><br><span class="line"><span class="function"><span class="params">(std::shared_ptr&lt;Widget&gt;)</span> $0 </span>= std::__shared_ptr&lt;Widget, __gnu_cxx::_S_atomic&gt;::element_type @ <span class="number">0x000055555556aeb0</span> &#123;</span><br><span class="line">  _M_ptr = <span class="number">0x000055555556aeb0</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="built_in">sp2</span></span><br><span class="line">(std::shared_ptr&lt;Widget&gt;) $<span class="number">1</span> = std::__shared_ptr&lt;Widget, __gnu_cxx::_S_atomic&gt;::element_type @ <span class="number">0x000055555556aeb0</span> &#123;</span><br><span class="line">  _M_ptr = <span class="number">0x000055555556aeb0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个对象希望通过shared_ptr分享所有权，应该采用<code>enable_shared_from_this</code></p>
<p>使用<code>enable_shared_from_this的</code>构造的内存模型如下<br><img src="/../imgs/22-12-28-1.png" alt="avatar"></p>
<p>对于类型<code>enable_shared_from_this</code>，其实现手段是自己存储了一个<code>weak_ptr</code>，在构造时赋值，<br>当使用<code>shared_from_this</code>，实际用这个weak_ptr生成</p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>Course_report</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Memory</tag>
        <tag>Smart_pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>Python代码加速实践(1)</title>
    <url>/2022/12/28/221228-2/</url>
    <content><![CDATA[<p>需求为，评估一段策略代码(python)实现，设计和实现C++的加速方案，具体的策略实现由于保密性，<br>不会给出，因此只有几个函数，以及部分样例数据</p>
<p>因此首先需要梳理函数之间的call_map,暂时不考虑并行部分，评估基本开销</p>
<p>梳理后得到下图</p>
<p>可见主体函数为resample_day </p>
<p>pivoting<br>参数<br>feature<br>df<br>hfq_multi_1min</p>
<p>save_feature<br>函数基本功能为 根据feature的种类 和 精度 队数据进行简单的处理 然后保存</p>
]]></content>
      <categories>
        <category>Tech</category>
        <category>工程实践</category>
        <category>量化策略</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11新特性解析与应用1</title>
    <url>/2022/12/25/221225-1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Tech</category>
        <category>Read_report</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>230101-1</title>
    <url>/2023/01/01/230101-1/</url>
    <content><![CDATA[<h1 id="计算机视觉算法的延迟观测"><a href="#计算机视觉算法的延迟观测" class="headerlink" title="计算机视觉算法的延迟观测"></a>计算机视觉算法的延迟观测</h1><h2 id="计算机视觉算法的运行时延"><a href="#计算机视觉算法的运行时延" class="headerlink" title="计算机视觉算法的运行时延"></a>计算机视觉算法的运行时延</h2><h3 id="基于计算图的模块抽象"><a href="#基于计算图的模块抽象" class="headerlink" title="基于计算图的模块抽象"></a>基于计算图的模块抽象</h3><p>计算机视觉算法的工业化部署中，一种主流的实现方式是模块化之后来构造计算图，具体做法是将计算机视觉算法分解为多个任务，然后使用任务图将这些任务组织起来，以便进行并行处理。任务图是一种有向无环图，每个节点表示一个任务，边表示任务之间的依赖关系。任务图的节点可以在不同的处理器上并行执行，以提高算法的运行效率。处于同一个进程地址空间内的计算，可以使用共享内存的方式来同步计算结果。部分处于不同的处理器，甚至是异构系统上，则通过消息传递的方式进行通信，这种实现方式需要使用一些网络信息传递框架(RPC)。例如地平线公司的天工开物，或者百度的paddle部署，都采用了类似的方式来实现对于底层的封装。</p>
<p><a href="https://developer.horizon.ai/api/v1/static/fileData/aitoolchain/_source/11_SDK_Reference.html">https://developer.horizon.ai/api/v1/static/fileData/aitoolchain/_source/11_SDK_Reference.html</a></p>
<p>[figure:描述module的结构]</p>
<p>使用计算图的封装和部署流程总体可以概括为前处理、模型推理和后处理三个阶段。具体来说，前处理阶段通常包括图像缩放、归一化、裁剪、色彩空间转换等操作，这些操作需要以图像数据为输入，输出符合模型输入要求的张量数据，根据具体的设计层次，可以封装为算子，也可以封装为计算图中的一个模块节点。后处理阶段通常包括后验概率转换、非极大值抑制、边框回归、关键点检测等操作，用于进一步优化模型的结果，这些操作也可以通过计算图中的节点来实现。</p>
<p>[figure:前后处理workflow]</p>
<p>模型推理阶段是计算图中的核心部分，包括卷积层、池化层、全连接层等多个节点，以及激活函数、归一化、Dropout等操作，每个节点都接受上一层的输出作为输入，输出结果经过下一层的处理，最终得到模型的分类或回归结果。但在模型的部署阶段，我们一般只会把模型作为一个端到端的模块来考虑，关注其吞吐量和计算延迟，而不会过度探索其内部的细节。</p>
<p>需要注意的是，用于推理计算的模块不一定只有一个，真实的业务部署场景有多个推理模型是非常常见的，可能是一个或者多个模型被反复构造，以达到ASIC或者GPU的计算和带宽负载上限为目的。此外，虽然专业硬件非常适合这一计算任务，少量情况下也会选择在CPU上运行。</p>
<p>[figure:多个实例化的推理]</p>
<p>完整考虑ref描述的部署外环境，模块的抽象还应该纳入IO部分。常见的IO模块一般用来处理传感器设备的数据收发，例如不同的实例化IO模块和各种规格设备的摄像机，磁盘设备，网络socket一一对应，生成具体的节点。无论作为输入还是输出，虽然没有具体的计算任务，但仍然需要进行完整的操作执行，因此同样应该提供对应的时间戳信息和附属的元信息。模块并不一定由单一的进程启动，例如负责发送数据的IO模块(负责管理某一相机设备的输入数据)，其完全可以单独运行，通过RPC的网络数据传输方式和计算图的其他节点通讯。基于这个前提，封装模块可能涉及多重实现语言(python,java,c++),和多个进程之间的数据通讯。</p>
<h3 id="计算机视觉算法的部署延迟测量"><a href="#计算机视觉算法的部署延迟测量" class="headerlink" title="计算机视觉算法的部署延迟测量"></a>计算机视觉算法的部署延迟测量</h3><h4 id="计算机视觉算法延迟的提取方式"><a href="#计算机视觉算法延迟的提取方式" class="headerlink" title="计算机视觉算法延迟的提取方式"></a>计算机视觉算法延迟的提取方式</h4><p>计算机视觉算法的部署延迟，通常是指从输入图像&#x2F;视频，到算法产生输出结果所需的时间。当以计算图的模块为单位，对整个算法执行过程中做出抽象的过程中，整个流程的调用关系已经确定。这意味着对延迟的测量并非只能和传统的服务端相同，粗略的计算端到端的时间开销，而是可以针对整个完整的计算机视觉算法运行流程，逐环节拆分为单步延迟，以此来提供整体的观测能见度。常见的拆分模块可以归类为负责数据发送，数据接收的IO模块，前处理，后处理的小型算子模块，沟通异构硬件的推理模块4个主要类型，以及处理一些特殊需求的模块。</p>
<p>和一般基于CPU的计算任务不同，计算机视觉算法模块之间一般根据功能特点切分，但不同节点，尤其是负责模型推理的模块，其工作负载明显超出一个数量级。如果对整体时延求和，则推理模块的权重占比过高，导致其他模块的性能优化点不易发现。例如推理延迟的具体数值，取决于使用的算法和实际的硬件设备。一般来说，现代GPU上执行一个pytorch直接生成的TorchScript模型，中等参数规模(例如retinaNet)的神经网络模型，推理延迟大致在几十个毫秒。经过TensorRT的量化(例如INT8)，最高可以实现在精度下降个位数百分点的范围内，减少50%的推理延迟。而单个前，后处理算子，基本不可能达到1ms的量级。但对于算子细节的实现优化并非没有意义，因为对于计算机视觉算法的部署而言，每一个算子都属于需要持续重复执行的热点路径(hot path), 如何对这些常用计算函数的效率进行优化，也是学术界一直讨论课题。</p>
<p><a href="https://openaccess.thecvf.com/content_CVPR_2019/papers/Cai_MaxpoolNMS_Getting_Rid_of_NMS_Bottlenecks_in_Two-Stage_Object_Detectors_CVPR_2019_paper.pdf">https://openaccess.thecvf.com/content_CVPR_2019/papers/Cai_MaxpoolNMS_Getting_Rid_of_NMS_Bottlenecks_in_Two-Stage_Object_Detectors_CVPR_2019_paper.pdf</a></p>
<p>而基于编译器层提供的性能观测工具(Nsight Compute，Vtune)，其切分的粒度一般以函数为单位，依赖于函数的符号表(Symbol table),其通过火焰图(fire flame)等方式进行可视化分析，帮助程序的使用者查找优化节点性能。这种方式的缺点在于颗粒度太小，如果以函数为单位，会需要记录海量的延迟信息，并且实时观测的开销太高，资源不足的情况下会影响算法本身的运行。</p>
<p>因此，论文设计了一种基于阶段(stage)选择的算法延迟测量方式，既考虑到观测能见度，也权衡了实时观测系统的低负载需求。具体的，以模块为时间戳获取的最小单位，一个阶段内可以放置多个模块。至少需要在一个阶段首个模块进入点，和最后一个模块的结束点，触发延迟的记录事件，捕获时间戳和上下文信息，并提交到专用的日志记录工具。</p>
<p>一般的场景下，对于由多个视觉算法组成的业务模型，数据所需要经过的环节和顺序都是固定的，其运行的整个流程具有一个树形的拓扑结构，获取一个观测的阶段，有两种不同的方式，对整个路径进行划分，由于整体是一个有向无环图，因此选择的阶段可能存在分支，也可能是无分叉的连续模块。对于一段无分支的区间，可以任意选择连续的模块构造一个或多个”阶段”，当一个区间存在分支，由于我们一般认为，同一个模块处理的计算任务是等价的(近似于无状态函数，数据处理的开销和数据的来源无关)，因此对重合的路径，应该切分处理，具体的，即一个阶段的选择，不能跨越产生分支的节点(可以作为端点)，应该阶段分叉前的部分，重新在后续路径上构造新的阶段。</p>
<p>最终对于延迟提取方式的描述，是一系列以阶段为分区的延迟数据采集关系，这种构造过程无需修改代码本身，而是通过外部的配置文件(config)。系统运行之前，会先实例化一个选择器(selector)，选择器通过读取配置文件的信息，确定阶段的划分方式，然后启动阶段两段模块上的内部设置为开启的观测点。这一机制依赖于操作系统内核的动态观测技术，具体实现在ref的环节会详细讨论。但可以概括为，在每个模块的出，入口上放置的观测节点，是通过选择器(selector)的启动后才具有触发延迟记录事件的功能，否则仅相当于一条不产生作用的空指令，不会导致额外的性能开销。</p>
<p>每一个阶段的延迟会被归档记录到一个日志中，通过获得开启的采样点时间戳，若对于单个模块，则开启和结束时间时间戳的差值就是模块的执行延迟，而到达下一个模块开启之前的时间，则可以视为调度和模块间的通讯延迟。这种情况下，不一定要选择阶段中全部的采样点，例如同一个进程地址空间之内的小计算模块之间的通讯和调度，大部分时候都没有观测的必要。</p>
<p>通过这一方式，可以灵活的控制观测的颗粒度，获取数据的详细程度取决于具体的需求。在软件的优化阶段，可以只选择前处理，后处理等部分的模块，避免推理模块的时延占比过高，不利于具体发现可以优化的模块，对比优化后的结果，可以只选择单一模块即可。运行时，延迟主要是用于事后的故障追踪，此时更多关注的硬件的情况，以外部传输，CPU侧，GPU(ASIC)侧来做大颗粒度划分，运行在同一硬件的连续模块直接归档到同一个阶段，减少产生的日志事件，降低观测的性能开销。</p>
<p>设计这种阶段选择的模式，实际生产中一个极大的便利点在于解除了业务软件本身和观测延迟部分的耦合，因为这种通过选择器去开启观测点的使用方式，并不会对软件目标运行产生影响，换而言之，采样和分析不会让被观测的对象所感知。这种方式构造了一种”热插拔”和”低耦合”，即采样和分析的工具是完全独立于生产系统，工具何时进行采样，何时和怎样进行统计分析，取决于工具的开发者和使用者。这使得测试不同模块的性能，只需要修改生成观测选择的配置文件，而不需要类似注入日志的方式，哪怕调整输出格式都需要直接重新修改和编译。并且”按需采集”的方式使得观测者对于软件的性能负载可以调节和控制，一种机制即可适配运行时和发布前不同的延迟观测需求。</p>
<h3 id="计算机视觉算法部署中的延迟元数据"><a href="#计算机视觉算法部署中的延迟元数据" class="headerlink" title="计算机视觉算法部署中的延迟元数据"></a>计算机视觉算法部署中的延迟元数据</h3><h4 id="延迟相关元数据"><a href="#延迟相关元数据" class="headerlink" title="延迟相关元数据"></a>延迟相关元数据</h4><p>当模块中的采样点触发延迟观测事件，获得此时的时间戳的同时，额外的程序状态信息，即论文所定义的延迟元数据。元数据通常被定义为描述数据的数据，对于延迟而言，即一些和延迟相关的状态信息，包括硬件状态和软件状态。</p>
<p>模块是一种对于底层实现的抽象，而硬件状态则指的是实际执行这一模块的物理环境，例如CPU&#x2F;GPU&#x2F;ASIC(NPU)的工作状态。以CPU侧的运行为例，一般包括内存占用(Memory usage),CPU当前频率和CPU主频(),当前CPU上等待执行的队列长度等信息。而对于负责神经网络推理，和部分特殊的前后处理计算的专用硬件(GPU&#x2F;NPU)而言，由于其实现的体系结构非常多样化，其观测的指标更多取决于硬件驱动直接提供的定量评估值，例如设备利用率，显存占用等。部分嵌入式环境下运行的硬件还会提供一些特殊的状态信息来辅助调试，例如NPU部分的电压值，常用于功耗分析和故障调试等场景。</p>
<p>软件状态信息则主要包括程序的上下文，一般包括程序当前所属的进程、线程ID，以及一些运行时产生的变量，一般还会根据需求，选择函数的参数堆栈，调用栈信息等。如何利用这些信息相当自由，甚至于可以根据一些特殊需求生成一些额外的信息。</p>
<p>这些额外信息是衡量可靠性的关键参考，获取元数据的能力，是观测系统中能见度的直观体现。本文拓展计算机视觉算法可观测维度的方式，就是利用软件的状态信息去制作延迟数据之间的钩子(hook)，而事后追踪的故障定位，也非常依赖于这些元数据信息。</p>
<h4 id="使用元数据拓展观测维度"><a href="#使用元数据拓展观测维度" class="headerlink" title="使用元数据拓展观测维度"></a>使用元数据拓展观测维度</h4><p>一般的服务端的观测工具，主要关注单一维度分析。例如最常用的一类工具，是用来对系统主要负载进行观测。举例iostat，主要用于监控系统设备的IO负载情况，用户可以通过指定统计的次数和时间来获得所需的统计信息，类似平均请求扇区的大小，平均请求队列的长度，每秒读&#x2F;写的扇区数(rsec&#x2F;wsec)等。这种观测一般仅限某个单独的维度，具体来说，这种观测类似于对系统运行某一个环节，进行横向的截面采样，统计的指标一般是同类数值的平均值&#x2F;最大值&#x2F;最小值等分布信息。</p>
<p>出现这种原因，一部分是因为这些工具诞生于早期的UNIX开发时期，”一个工具只做一件事，但要做好”（”Do one thing and do it well”）是Unix系统设计的核心理念之一，它强调简单性、可组合性和可重用性。按照这一原则，每个工具只需要专注于解决一种问题，但是要尽可能地将其解决得彻底。这种设计方式使得Unix系统变得高效、灵活且易于维护。此外，每个工具都可以通过标准输入和输出进行协作，从而实现高度的可组合性和可重用性，另一方面是客观的技术条件限制，更高的观测可见度，实现的工作量太大，意义有限。</p>
<p>在计算机视觉算法的延迟数据观测中，我们重点提到了使用传统方式，观测维度不足的问题ref(研究的出发点)，这和现代软件工程的多层次导致的复杂性是类似的，简单的日志输出或者单一环节负载观测, 由于信息不足(采样的数据只服务于统计指标)，很难在多个模块或层次之间建立联系。例如上述采样点所获得的时间戳数据，即便了解采样点的位置，但无法判断延迟具体归属于哪一份数据，举例而言，上文所描述的构造阶段，就是以时间的维度，考虑每一张图片具体在每个环节上的时间开销。这种纵向观测维度是非常有意义的，尤其针对之前所描述的”延迟窗口期”问题，以及这种方式可以非常清晰的体现出数据和计算之间的关系，而不会因为平均值等统计的原因被抹平。</p>
<p>本文实现这种跨越阶段的数据联系，是通过以一些元数据作为数据之间匹配的唯一键，通过哈希表这一数据结构，创造一些延迟数据之间的钩子(hook)，这一实现方式深度依赖操作系统内核新特性的支持，在ref中会做具体介绍。</p>
<h2 id="计算机算法的延迟观测意义"><a href="#计算机算法的延迟观测意义" class="headerlink" title="计算机算法的延迟观测意义"></a>计算机算法的延迟观测意义</h2><h3 id="计算图调度的分派优化"><a href="#计算图调度的分派优化" class="headerlink" title="计算图调度的分派优化"></a>计算图调度的分派优化</h3><p>计算图调度是指对计算图中的操作进行排序和调度，以便在计算中最大化利用资源并最小化延迟。这通常涉及将依赖关系转化为并发操作和数据流，并将操作分配到可用的计算资源上。常用的技术是基于DAG（有向无环图）的调度算法，在对各个模块的依赖关系确定后，将DAG中的节点排序，以便操作可以按照正确的顺序执行。可以使用拓扑排序算法来实现。将操作分配给可用的计算资源，以最大化并发性, 在分配资源后，需要将操作调度到实际的计算资源上，例如GPU,CPU,ASIC。这通常涉及将操作映射到适当的设备上，并将其分配到可用的计算资源中。</p>
<p>对于前处理和后处理阶段，应该根据具体的应用场景来选择使用CPU还是专用硬件进行计算。CPU的优点是具有较强的通用性和灵活性，能够适应各种不同的计算任务，具有较高的单线程执行性能，在处理一些计算较少、但需要高并发处理的任务时比较优秀。一般的，由于CPU资源普遍更加富余，且前后处理需要对接外部新信息的输入输出，涉及到网络和IO的场景，因此大部分情况下会派发到CPU，少数边缘计算的硬件，其内存和专用计算硬件的显存在主板上可以直连，拷贝代价较低，则会使用专用算子进行执行，这些细节对会被封装在模块执行的内部。</p>
<p>由于对于一个固定功能的模块，在不考虑线程切换的开销下，需要执行的计算任务完全相同，因此理论上单个计算节点通过一份数据的时间应该会在一个相对稳定的范围内波动。在这种前提下，延迟信息可以近似等价于工作负载，作为计算图调度的重要参考依据。然而由于针对不同的硬件情况，以及软件的支持情况，模块的实现方式都是不同的，虽然可以提供具有一致的接口，但实际上运行的表现会有较大的差异。一个典型的例子就是部署过程中对于模型的量化，这种技术将浮点型参数和激活值转换为低位宽的整数类型，从而在不显著降低模型精度的情况下减小模型的存储和计算开销。由于量化后的计算需要更少的存储空间和计算资源，因此可以显著降低模型推理的延迟。量化后不仅减少了存储和带宽的需求，同时整数计算还大幅度的减少了计算开销，由于现代硬件加速器（如FPGA和ASIC）通常采用定点计算，因此量化可以更好地适配这些硬件，从而显著提高计算性能。这会使得即便是理论上最稳定的推理部分，实际部署的过程也会因为精度的需求不同，表现出完全不同的延迟。至于算子则取决于硬件的支持以及实现的完成度。</p>
<p>[figure:抽象表示]<br>[figure:量化]</p>
<p>虽然延迟可以近似理解为在特定资源上的工作负载，但是在ARM硬件中，CPU存在大小核的情况，即某些处理器有一些性能更高的大核心和一些性能较低的小核心。对于一个相同计算负载的任务，例如一个前处理任务，在大核心上会具有更小的延迟，最好的情况下，我们还希望能捕获这种更细致颗粒度的信息作为优化参考，但ref的描述，基于一般的日志系统，这类元信息的获取在性能负载上并不廉价。</p>
<p>[figure:任务负载调度和派发]</p>
<p>因此，延迟的观测数据可以作为一种重要的优化参考存在，但不是一个确定的常数，而是需要根据具体的部署状态去进行测量，一个颗粒度可以自由控制的延迟观测系统，在优化阶段可以发挥相当多的作用。</p>
<h3 id="优化参数设置"><a href="#优化参数设置" class="headerlink" title="优化参数设置"></a>优化参数设置</h3><p>部分参数的设定也会影响系统的性能，一个比较常见的指标是线程池的大小设置，线程池是一种用于管理和调度线程的技术，可以有效地利用系统资源，提高系统的性能和响应速度。对于计算机视觉任务来说，其关键瓶颈通常在模型推理部分，要尽可能的减少其等待时间时间。线程池可以预先创建一定数量的线程，每当获得模型的输出是，快速的为推理模块填充新的输入。视觉算法通常需要处理大量的图像和视频数据，需要大量的并发和并行，因此线程池可以带来良好的重用，减少线程的创建和销毁造成的系统负荷，但也需要根据具体的应用场景来进行评估和调整，例如根据延迟信息代表的工作负载，避免设定太多的线程造成过多上下文切换过多，同时也应该考虑内存占用的问题，这一点在嵌入式系统的边缘计算中尤其重要。</p>
<p>在延迟的观测维度中，可以不止存在一个维度。具体而言，对于ref这样的推理模块，其运行的延迟可以以数据分布的形式统计，考察同一类模块执行计算任务时间开销的变化情况。另一个观测维度则是根据数据本身而言，即数据从进入计算机视觉算法系统开始，到获得对应的结果信息对应在每个环节的延迟开销。这当中必然还存在一些等待时间，例如在线程池中排队等待响应，以及对应线程在CPU上经过的上下文切换数量。如果等待时间占比太长，发生的线程调度过于频繁，则说明线程池设置的规模太大，参数配置并不合理。</p>
<h3 id="事后追踪作用"><a href="#事后追踪作用" class="headerlink" title="事后追踪作用"></a>事后追踪作用</h3><p>日志的事后追踪能力是指在程序运行过程中，将程序的关键信息和状态记录下来，并保存到日志中，以便在程序出现问题或异常时，能够通过分析日志来查找问题和排除故障。计算机视觉算法在运行时的延迟信息，以及一些附带的元数据，包括时间戳、线程ID、进程ID、运行环境，以及可以控制颗粒度的，具体在哪一个模块运行这样用来描述程序执行路径的上下文信息。这样的筛查能力可以在端到端的总体延迟出现波动时，可以快速排查到出现故障的模块，提供一种可定位性。</p>
<p>大部分边缘业务因为数据和安全性的考虑，基本只在内网环境，本质上在离线状态下进行长时间运行。当出现一些偶发的故障，需要排查和处理，由于嵌入式系统的部署特点，一般只能通过对历史故障的描述，至少在几个小时或者几天后，先将服务下线，然后才能开始尝试复现故障问题，这种重现由于缺少参考信息，一般非常困难。</p>
<p>事后追踪能力主要就是为这一情况提供帮助，记录一些额外的参考信息。本文讨论的延迟数据，一个重要作用，就是可以通过延迟数据日志来定位故障发生的时间点，以及根据延迟出现异常波动的具体环节，推测故障发生在运行中的位置。特别的，延迟的元信息，即软件硬件的状态信息，由于是一种”活体观测”的运行时数据，因此非常宝贵，相当于不需要重现故障，就可以获得事件发生时的关键信息。</p>
]]></content>
  </entry>
  <entry>
    <title>使用absl时间库实现类python-timestramp部分功能</title>
    <url>/2023/01/01/230101-2/</url>
    <content><![CDATA[<h2 id="时间精度"><a href="#时间精度" class="headerlink" title="时间精度"></a>时间精度</h2><p><img src="/../imgs/23-01-07-0.png" alt="avatar"><br>现有数据的时间精度参考上述数据，在初始阶段，其时间精度包含两个部分</p>
<ul>
<li>[1] <code>date</code>精确度到日期</li>
<li>[2] <code>updatetime &amp;&amp; localtime</code>精确到毫秒<code>ms</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aa[<span class="string">&#x27;datetime&#x27;</span>] = pd.to_datetime(aa[<span class="string">&#x27;date&#x27;</span>].apply(<span class="built_in">str</span>)+<span class="string">&#x27; &#x27;</span>+aa[<span class="string">&#x27;updatetime&#x27;</span>].apply(<span class="built_in">str</span>))</span><br></pre></td></tr></table></figure>
<img src="/../imgs/23-01-07-1.png" alt="avatar"><br>但考察转化成<code>datetime</code>以后的精度，实质上截断了<code>sec</code>以后的所有精度</li>
</ul>
<p>考察之后涉及的操作</p>
<h3 id="Resample"><a href="#Resample" class="headerlink" title="Resample"></a>Resample</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ff.resample(<span class="string">f&#x27;D&#x27;</span>)</span><br><span class="line">ff.resample(<span class="string">f&#x27;<span class="subst">&#123;period&#125;</span>T&#x27;</span>,label=<span class="string">&#x27;right&#x27;</span>,closed=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">between_time(<span class="string">&#x27;09:30&#x27;</span>,<span class="string">&#x27;11:30&#x27;</span>,inclusive=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">pd.Grouper(key=<span class="string">&#x27;datetime&#x27;</span>,freq=<span class="string">f&#x27;T&#x27;</span>,closed=<span class="string">&#x27;right&#x27;</span>,label=<span class="string">&#x27;right&#x27;</span>,dropna=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Tech</category>
        <category>工程实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Python</tag>
        <tag>Time</tag>
      </tags>
  </entry>
  <entry>
    <title>Parallel Algorithms of STL</title>
    <url>/2023/01/01/230108-1/</url>
    <content><![CDATA[<h1 id="Parallel-STL-of-C-17"><a href="#Parallel-STL-of-C-17" class="headerlink" title="Parallel STL of C++17"></a>Parallel STL of C++17</h1><p>C++标准库在17版本引入了通过<code>execution policy</code>来指定算法的并行执行策略和向量化方式</p>
<p>其需要<code>#include&lt;execution&gt;</code></p>
<p>在<code>STL</code>中有超过一百种基础算法，在<code>parallel STL</code>中对<code>69</code>种进行了重载，新增了<code>8</code>种</p>
<h2 id="Execution-Policies"><a href="#Execution-Policies" class="headerlink" title="Execution Policies"></a>Execution Policies</h2><p>C++的基础标准提供了三种策略</p>
<ul>
<li>[1]<code>std::execution::sequenced_policy</code></li>
<li>[2]<code>std::execution::parallel_policy</code></li>
<li>[3]<code>std::execution::parallel_unsequenced_policy</code><br>其对应3个tag，对应不同的执行策略，分别为顺序执行，并行执行，和向量化并行</li>
<li>[1]<code>std::execution::seq</code> 一般的顺序执行策略</li>
<li>[2]<code>std::execution::par</code> 启用多线程的并行执行策略</li>
<li>[3]<code>std::execution::par_unseq</code> 允许循环的交错执行，允许指令的向量化<code>(SIMD)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">std::<span class="built_in">sort</span>(std::execution::seq,v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>C++ 同时允许 <code>std::is_execution_policy</code>来检查是否是标准的执行策略</p>
<h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><h3 id="std-adjacent-difference-amp-amp-adjacent-find"><a href="#std-adjacent-difference-amp-amp-adjacent-find" class="headerlink" title="std::adjacent_difference &amp;&amp;　adjacent_find"></a>std::adjacent_difference &amp;&amp;　adjacent_find</h3><p>计算相邻元素的差或者和 可以自定义函数op 选择对象是相邻的元素<br>查找两个连续元素　满足一个规则</p>
<h3 id="std-copy-amp-amp-std-copy-if-amp-amp-copy-n"><a href="#std-copy-amp-amp-std-copy-if-amp-amp-copy-n" class="headerlink" title="std::copy &amp;&amp; std::copy_if &amp;&amp; copy_n"></a>std::copy &amp;&amp; std::copy_if &amp;&amp; copy_n</h3><p>序列拷贝到序列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">copy_if</span>(from_vector.<span class="built_in">begin</span>(), from_vector.<span class="built_in">end</span>(),</span><br><span class="line">                std::<span class="built_in">back_inserter</span>(to_vector),</span><br><span class="line">                [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="std-count-amp-amp-std-count-if-amp-amp-std-count-if-not"><a href="#std-count-amp-amp-std-count-if-amp-amp-std-count-if-not" class="headerlink" title="std::count &amp;&amp; std::count_if &amp;&amp; std::count_if_not"></a>std::count &amp;&amp; std::count_if &amp;&amp; std::count_if_not</h3><h3 id="std-find-amp-amp-std-find-end-amp-amp-find-first-of-amp-amp-find-if"><a href="#std-find-amp-amp-std-find-end-amp-amp-find-first-of-amp-amp-find-if" class="headerlink" title="std::find &amp;&amp; std::find_end &amp;&amp; find_first_of &amp;&amp; find_if"></a>std::find &amp;&amp; std::find_end &amp;&amp; find_first_of &amp;&amp; find_if</h3><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><h3 id="std-fill-amp-amp-std-fill-n"><a href="#std-fill-amp-amp-std-fill-n" class="headerlink" title="std::fill &amp;&amp; std::fill_n"></a>std::fill &amp;&amp; std::fill_n</h3><h3 id="std-inner-product"><a href="#std-inner-product" class="headerlink" title="std::inner_product"></a>std::inner_product</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; b&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> r1 = std::<span class="built_in">inner_product</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inner product of a and b: &quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> r2 = std::<span class="built_in">inner_product</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), <span class="number">-1</span>,</span><br><span class="line">                                std::plus&lt;&gt;(), std::equal_to&lt;&gt;());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of pairwise matches between a and b: &quot;</span> &lt;&lt;  r2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的设计有意思的地方在于，实质上没有限制具体需要实现的函数接口，内积只是一个表达形式，其实际的实现是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">         <span class="keyword">class</span> <span class="title class_">BinaryOperation1</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation2</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="comment">// since C++20</span></span><br><span class="line"><span class="function">T <span class="title">inner_product</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                InputIt2 first2, T init,</span></span></span><br><span class="line"><span class="params"><span class="function">                BinaryOperation1 op1</span></span></span><br><span class="line"><span class="params"><span class="function">                BinaryOperation2 op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first1 != last1)</span><br><span class="line">    &#123;</span><br><span class="line">         init = <span class="built_in">op1</span>(std::<span class="built_in">move</span>(init), <span class="built_in">op2</span>(*first1, *first2)); <span class="comment">// std::move since C++20</span></span><br><span class="line">         ++first1;</span><br><span class="line">         ++first2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此两个接口有很强的拓展性,具体的可以理解为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair_wise + iter </span><br></pre></td></tr></table></figure>
<p>但目前的stl并行还没有支持，不知道为什么书里写了</p>
<h3 id="std-find-amp-amp-std-find-if-not"><a href="#std-find-amp-amp-std-find-if-not" class="headerlink" title="std::find &amp;&amp; std::find_if_not"></a>std::find &amp;&amp; std::find_if_not</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> UnaryPredicate&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> InputIt <span class="title">find_if_not</span><span class="params">(InputIt first, InputIt last, UnaryPredicate q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">q</span>(*first))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="is-partitioned-amp-amp-partition"><a href="#is-partitioned-amp-amp-partition" class="headerlink" title="is_partitioned &amp;&amp; partition"></a>is_partitioned &amp;&amp; partition</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> UnaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_partitioned</span><span class="params">(InputIt first, InputIt last, UnaryPredicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">p</span>(*first))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(*first))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很有用的工具，可以利用函数进行二元分区</p>
<h3 id="max-element"><a href="#max-element" class="headerlink" title="max_element"></a>max_element</h3><h3 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h3><p>查看两个序列是否匹配，以及不匹配的位置</p>
<h3 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h3><p>部分排序</p>
<h3 id="remove-amp-amp-remove-if-amp-amp-remove-copy-amp-amp-remove-copy-if"><a href="#remove-amp-amp-remove-if-amp-amp-remove-copy-amp-amp-remove-copy-if" class="headerlink" title="remove &amp;&amp; remove_if &amp;&amp; remove_copy &amp;&amp; remove_copy_if"></a>remove &amp;&amp; remove_if &amp;&amp; remove_copy &amp;&amp; remove_copy_if</h3><p>满足条件则删除 或者满足值就删除</p>
<h3 id="replace-amp-amp-replace-copy-amp-amp-replace-copy-if"><a href="#replace-amp-amp-replace-copy-amp-amp-replace-copy-if" class="headerlink" title="replace &amp;&amp; replace_copy &amp;&amp; replace_copy_if"></a>replace &amp;&amp; replace_copy &amp;&amp; replace_copy_if</h3><h3 id="reverse-amp-amp-reverse-copy-amp-amp-reverse-copy-if"><a href="#reverse-amp-amp-reverse-copy-amp-amp-reverse-copy-if" class="headerlink" title="reverse &amp;&amp; reverse_copy &amp;&amp; reverse_copy_if"></a>reverse &amp;&amp; reverse_copy &amp;&amp; reverse_copy_if</h3><h3 id="rotate-amp-amp-rotate-copy"><a href="#rotate-amp-amp-rotate-copy" class="headerlink" title="rotate &amp;&amp; rotate_copy"></a>rotate &amp;&amp; rotate_copy</h3><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><h3 id="std-set-symmetric-difference"><a href="#std-set-symmetric-difference" class="headerlink" title="std::set_symmetric_difference"></a>std::set_symmetric_difference</h3><p>在两个集合有序的情况下，求对称的差集</p>
<h3 id="std-stable-sort-amp-amp-std-stable-partition"><a href="#std-stable-sort-amp-amp-std-stable-partition" class="headerlink" title="std::stable_sort &amp;&amp; std::stable_partition"></a>std::stable_sort &amp;&amp; std::stable_partition</h3><p>排序，用处不大</p>
<h3 id="std-uninitialized-copy-n"><a href="#std-uninitialized-copy-n" class="headerlink" title="std::uninitialized_copy_n"></a>std::uninitialized_copy_n</h3><p>拷贝一定数量的元素</p>
<h3 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy"></a>unique_copy</h3><p>去除相邻的重复元素</p>
<h3 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h3><p>判断相等</p>
<h3 id="std-inplace-merge"><a href="#std-inplace-merge" class="headerlink" title="std::inplace_merge"></a>std::inplace_merge</h3><p>归并排序的实现 本地</p>
<h3 id="is-sorted-amp-amp-is-sorted-until"><a href="#is-sorted-amp-amp-is-sorted-until" class="headerlink" title="is_sorted &amp;&amp; is_sorted_until"></a>is_sorted &amp;&amp; is_sorted_until</h3><p>查看是否是一个偏序列关系集合</p>
<h3 id="all-of-amp-amp-all-of-amp-amp-none-of"><a href="#all-of-amp-amp-all-of-amp-amp-none-of" class="headerlink" title="all_of &amp;&amp; all_of &amp;&amp; none_of"></a>all_of &amp;&amp; all_of &amp;&amp; none_of</h3><p>返回一个bool值 对一个迭代范围进行判断</p>
<h3 id="max-element-amp-amp-min-element-amp-amp-minmax-element-amp-amp-nth-element"><a href="#max-element-amp-amp-min-element-amp-amp-minmax-element-amp-amp-nth-element" class="headerlink" title="max_element &amp;&amp; min_element &amp;&amp; minmax_element &amp;&amp; nth_element"></a>max_element &amp;&amp; min_element &amp;&amp; minmax_element &amp;&amp; nth_element</h3><h3 id="generate-amp-amp-generate"><a href="#generate-amp-amp-generate" class="headerlink" title="generate &amp;&amp; generate()"></a>generate &amp;&amp; generate()</h3>]]></content>
      <categories>
        <category>Tech</category>
        <category>Read_report</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Parallel</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/01/10/230110-1/</url>
    <content><![CDATA[<h1 id="方海舟-岗位志愿相关"><a href="#方海舟-岗位志愿相关" class="headerlink" title="方海舟 岗位志愿相关"></a>方海舟 岗位志愿相关</h1><h2 id="开发技术栈"><a href="#开发技术栈" class="headerlink" title="开发技术栈"></a>开发技术栈</h2><h3 id="熟悉"><a href="#熟悉" class="headerlink" title="熟悉:"></a>熟悉:</h3><ul>
<li>[1] C++<br>基础组件&#x2F;多线程&#x2F;网络，IO&#x2F;并行计算&#x2F;模板&#x2F;动态，静态链接库<br>Infrastructure&#x2F;Concurrency&#x2F;Parallelism&#x2F;Network&#x2F;storage&#x2F;Template&#x2F;MetaProgramming&#x2F;Dynamic,static lib</li>
</ul>
<h3 id="了解"><a href="#了解" class="headerlink" title="了解:"></a>了解:</h3><ul>
<li>[2] C 内核调试&#x2F;IO&#x2F;存储</li>
<li>[3] go 后端服务&#x2F;存储&#x2F;RPC&#x2F;消息队列</li>
<li>[4] java 中间件&#x2F;数据库事物(transaction)</li>
<li></li>
</ul>
<h3 id="运用"><a href="#运用" class="headerlink" title="运用:"></a>运用:</h3><ul>
<li>[5] python pandas&#x2F;numpy&#x2F;ffi&#x2F;可视化&#x2F;机器学习&#x2F;深度学习&#x2F;pytorch</li>
</ul>
<h2 id="岗位方向"><a href="#岗位方向" class="headerlink" title="岗位方向:"></a>岗位方向:</h2><p>希望为业务应用，但是对实现性能有要求，类似面试聊过的交易撮合</p>
<h2 id="岗位志愿"><a href="#岗位志愿" class="headerlink" title="岗位志愿:"></a>岗位志愿:</h2><p>志愿1: 后端开发<br>志愿2: 数据库开发<br>志愿3: 大数据与AI</p>
<h2 id="岗位志愿的选择理由"><a href="#岗位志愿的选择理由" class="headerlink" title="岗位志愿的选择理由:"></a>岗位志愿的选择理由:</h2><p>理由1: 对金融业务知识有一定的了解，入职前应该会考完期货从业资格，目前在<strong>远澜信息</strong>的<strong>量化商品期货CTA策略</strong>部门实习，主要为对<strong>信号策略的C++实现(高性能计算)<strong>和</strong>业务系统(go java)</strong>, 因此希望能做和业务相关的后端，但有一定性能需求的内容的场景</p>
<p>理由2: 之前在<strong>华为</strong>的实习项目主要为开发对<strong>系统IO监测</strong>工具的开发，其中包括一部分对数据库的评估和分析，对<strong>数据库</strong>没有较多实际使用经验，但学习过主要运行原理和性能分析，也包括其外置的缓存中间件等</p>
]]></content>
  </entry>
</search>
